package CN;

import java.util.*;

public class bell {

    private int D[];
    private int num_ver;
    public static final int MAX_VALUE = 999;

    // Constructor â€” no return type!
    public bell(int num_ver) {
        this.num_ver = num_ver;
        D = new int[num_ver + 1];
    }

    public void BellmanFordEvaluation(int source, int A[][]) {
        Arrays.fill(D, MAX_VALUE);
        D[source] = 0;

        for (int i = 1; i <= num_ver - 1; i++) {
            for (int sn = 1; sn <= num_ver; sn++) {
                for (int dn = 1; dn <= num_ver; dn++) {
                    if (A[sn][dn] != MAX_VALUE && D[sn] != MAX_VALUE && D[dn] > D[sn] + A[sn][dn]) {
                        D[dn] = D[sn] + A[sn][dn];
                    }
                }
            }
        }

        for (int sn = 1; sn <= num_ver; sn++) {
            for (int dn = 1; dn <= num_ver; dn++) {
                if (A[sn][dn] != MAX_VALUE && D[sn] != MAX_VALUE && D[dn] > D[sn] + A[sn][dn]) {
                    System.out.println("The graph contains a negative weight cycle.");
                    return;
                }
            }
        }

        for (int vertex = 1; vertex <= num_ver; vertex++) {
            if (D[vertex] == MAX_VALUE) {
                System.out.println("Distance from source " + source + " to vertex " + vertex + " is INF.");
            } else {
                System.out.println("Distance from source " + source + " to vertex " + vertex + " is " + D[vertex]);
            }
        }
    }

    // Main method to run the program
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        System.out.print("Enter the number of vertices: ");
        int num_ver = scanner.nextInt();

        int[][] A = new int[num_ver + 1][num_ver + 1];

        System.out.println("Enter the adjacency matrix (use 0 for no edge):");
        for (int i = 1; i <= num_ver; i++) {
            for (int j = 1; j <= num_ver; j++) {
                A[i][j] = scanner.nextInt();
                if (i == j) {
                    A[i][j] = 0; // Distance to self is zero
                } else if (A[i][j] == 0) {
                    A[i][j] = MAX_VALUE; // No edge represented as MAX_VALUE
                }
            }
        }

        System.out.print("Enter the source vertex: ");
        int source = scanner.nextInt();

        bell bf = new bell(num_ver);
        bf.BellmanFordEvaluation(source, A);

        scanner.close();
    }
}



Enter the number of vertices: 4
Enter the adjacency matrix (use 0 for no edge):
0 4 0 0
0 0 5 0
0 0 0 -2
0 0 0 0
Enter the source vertex: 1
Distance from source 1 to vertex 1 is 0
Distance from source 1 to vertex 2 is 4
Distance from source 1 to vertex 3 is 9
Distance from source 1 to vertex 4 is 7
